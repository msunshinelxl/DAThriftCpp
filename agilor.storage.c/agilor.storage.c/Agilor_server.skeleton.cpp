// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Agilor.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/concurrency/ThreadManager.h>

#include <thrift/concurrency/StdThreadFactory.h>
#include "AgilorHandler.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

//class AgilorHandler : virtual public AgilorIf {
// public:
//  AgilorHandler() {
//    // Your initialization goes here
//  }
//
//  void ping() {
//    // Your implementation goes here
//    printf("ping\n");
//  }
//
//  bool AddDevice(const DEVICE& device) {
//    // Your implementation goes here
//    printf("AddDevice\n");
//  }
//
//  bool DeleteDevice(const std::string& deviceName) {
//    // Your implementation goes here
//    printf("DeleteDevice\n");
//  }
//
//  bool ModifyDevice(const DEVICE& device) {
//    // Your implementation goes here
//    printf("ModifyDevice\n");
//  }
//
//  int64_t QueryDeviceInfo() {
//    // Your implementation goes here
//    printf("QueryDeviceInfo\n");
//  }
//
//  void EnumDeviceInfo(DEVICE& _return, const int64_t hRecordset) {
//    // Your implementation goes here
//    printf("EnumDeviceInfo\n");
//  }
//
//  void GetAllDevices(std::vector<DEVICE> & _return) {
//    // Your implementation goes here
//    printf("GetAllDevices\n");
//  }
//
//  int64_t QuerySnapshots(const std::string& tagNames, const int32_t tagCount) {
//    // Your implementation goes here
//    printf("QuerySnapshots\n");
//  }
//
//  void GetNextTagValue(TAGVAL& _return, const int64_t hRecordset, const bool isRemoved) {
//    // Your implementation goes here
//    printf("GetNextTagValue\n");
//  }
//
//  int64_t QueryTagHistory(const std::string& tagName, const int64_t startTime, const int64_t endTime, const int64_t step) {
//    // Your implementation goes here
//    printf("QueryTagHistory\n");
//  }
//
//  void GetAggregateValue(TAGVAL& _return, const int64_t hRecordset, const AGGREGATE::type ag, const bool isRemoved) {
//    // Your implementation goes here
//    printf("GetAggregateValue\n");
//  }
//
//  int64_t QueryTagsbyDevice(const std::string& deviceName) {
//    // Your implementation goes here
//    printf("QueryTagsbyDevice\n");
//  }
//
//  void EnumTagName(std::string& _return, const int64_t hRecordset) {
//    // Your implementation goes here
//    printf("EnumTagName\n");
//  }
//
//  void GetTagNamebyId(std::string& _return, const int64_t tagId) {
//    // Your implementation goes here
//    printf("GetTagNamebyId\n");
//  }
//
//  int64_t SetValue(const TAGVAL& value) {
//    // Your implementation goes here
//    printf("SetValue\n");
//  }
//
//  int64_t RemoveTag(const int64_t tagId) {
//    // Your implementation goes here
//    printf("RemoveTag\n");
//  }
//
//  void GetTagInfo(TAGNODE& _return, const std::string& tagName) {
//    // Your implementation goes here
//    printf("GetTagInfo\n");
//  }
//
//  int64_t AddNewTag(const TAGNODE& node, const bool isOverwrite) {
//    // Your implementation goes here
//    printf("AddNewTag\n");
//  }
//
//  void EnumNextTag(TAGNODE& _return, const int64_t hwnd) {
//    // Your implementation goes here
//    printf("EnumNextTag\n");
//  }
//
//  int64_t SubscribeTags(const std::string& tagNames) {
//    // Your implementation goes here
//    printf("SubscribeTags\n");
//  }
//
//  void GetSubTagValue(TAGVAL& _return) {
//    // Your implementation goes here
//    printf("GetSubTagValue\n");
//  }
//
//  int64_t UnSubscribeTags(const std::string& tagNames) {
//    // Your implementation goes here
//    printf("UnSubscribeTags\n");
//  }
//
//  int64_t UnSubscribeAll() {
//    // Your implementation goes here
//    printf("UnSubscribeAll\n");
//  }
//
//};

int main(int argc, char **argv) {
	int port = 9090;
	boost::shared_ptr<AgilorHandler> handler(new AgilorHandler());
	boost::shared_ptr<TProcessor> processor(new AgilorProcessor(handler));
	boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
	boost::shared_ptr<StdThreadFactory>threadFactory(new StdThreadFactory());

	threadManager->threadFactory(threadFactory);
	threadManager->start();
	

	//TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
	server.serve();
	return 0;
}

